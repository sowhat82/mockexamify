"""
Admin Manage Mock Exams Page
Allows admins to view, edit, and delete mock exams
"""
import streamlit as st
from typing import List, Dict, Any
from auth_utils import AuthUtils, run_async
import config
import json

def show_admin_manage():
    """Display admin manage mock exams page"""
    auth = AuthUtils(config.API_BASE_URL)

    if not auth.is_authenticated() or not auth.is_admin():
        st.error("Admin access required")
        st.stop()

    st.markdown("# üìù Manage Mock Exams")
    st.markdown("View, edit, and manage all mock exams in the system")

    # Load all mocks
    try:
        mocks = run_async(load_all_mocks())

        if not mocks:
            st.info("No mock exams found. Create your first mock exam!")
            if st.button("üì§ Upload New Mock"):
                st.session_state.page = "admin_upload"
                st.rerun()
            return

        # Stats
        active_mocks = [m for m in mocks if m.get('is_active', True)]
        total_questions = sum(len(m.get('questions_json', [])) for m in mocks)

        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Total Mocks", len(mocks))
        with col2:
            st.metric("Active Mocks", len(active_mocks))
        with col3:
            st.metric("Total Questions", total_questions)
        with col4:
            if st.button("üì§ Upload New Mock", use_container_width=True):
                st.session_state.page = "admin_upload"
                st.rerun()

        st.markdown("---")

        # Search and filter
        col1, col2, col3 = st.columns([2, 1, 1])
        with col1:
            search_term = st.text_input("üîç Search mocks", placeholder="Search by title or description...")
        with col2:
            category_filter = st.selectbox("Category", ["All"] + get_unique_categories(mocks))
        with col3:
            status_filter = st.selectbox("Status", ["All", "Active", "Inactive"])

        # Filter mocks
        filtered_mocks = filter_mocks(mocks, search_term, category_filter, status_filter)

        if not filtered_mocks:
            st.info("No mocks match your search criteria")
            return

        # Display mocks
        for mock in filtered_mocks:
            show_mock_card(mock)

    except Exception as e:
        st.error(f"Error loading mocks: {str(e)}")

def show_mock_card(mock: Dict[str, Any]):
    """Display a single mock exam card with management options"""
    with st.container():
        # Mock header
        col1, col2, col3 = st.columns([3, 1, 1])

        with col1:
            status_badge = "üü¢ Active" if mock.get('is_active', True) else "üî¥ Inactive"
            explanation_badge = "üí° Explanations" if mock.get('explanation_enabled', False) else ""

            st.markdown(f"""
            ### {mock.get('title', 'Untitled Mock')} {status_badge}
            **Category:** {mock.get('category', 'General')} | **Credits:** {mock.get('price_credits', 1)} | {explanation_badge}

            {mock.get('description', 'No description')}
            """)

        with col2:
            if st.button(f"‚úèÔ∏è Edit", key=f"edit_{mock['id']}", use_container_width=True):
                st.session_state.edit_mock_id = mock['id']
                st.session_state.show_edit_form = True

        with col3:
            if st.button(f"üóëÔ∏è Delete", key=f"delete_{mock['id']}", use_container_width=True, type="secondary"):
                st.session_state.delete_mock_id = mock['id']
                st.session_state.show_delete_confirm = True

        # Mock details
        questions = mock.get('questions_json', [])
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("Questions", len(questions))
        with col2:
            st.metric("Time Limit", f"{mock.get('time_limit_minutes', 60)} min")
        with col3:
            created_at = mock.get('created_at', '')
            if created_at:
                try:
                    from datetime import datetime
                    date_obj = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                    formatted_date = date_obj.strftime('%Y-%m-%d')
                    st.metric("Created", formatted_date)
                except:
                    st.metric("Created", "Unknown")
        with col4:
            if st.button(f"ü§ñ Regenerate Explanations", key=f"regen_{mock['id']}", use_container_width=True):
                run_async(regenerate_explanations(mock['id']))
                st.success("Explanations regenerated!")
                st.rerun()

        # Show questions preview
        with st.expander(f"üëÄ Preview Questions ({len(questions)} total)"):
            if questions:
                for i, q in enumerate(questions[:3]):  # Show first 3 questions
                    st.markdown(f"**Q{i+1}:** {q.get('question', 'No question text')}")
                    choices = q.get('choices', [])
                    correct_idx = q.get('correct_index', 0)

                    for j, choice in enumerate(choices):
                        marker = "‚úÖ" if j == correct_idx else "‚óØ"
                        st.markdown(f"  {marker} {choice}")

                    if i < 2 and i < len(questions) - 1:
                        st.markdown("---")

                if len(questions) > 3:
                    st.info(f"... and {len(questions) - 3} more questions")
            else:
                st.warning("No questions found in this mock")

        st.markdown("---")

def show_edit_mock_form(mock_id: str):
    """Show edit form for a mock exam"""
    with st.expander("‚úèÔ∏è Edit Mock Exam", expanded=True):
        # Load mock data
        mock = run_async(load_mock_by_id(mock_id))

        if not mock:
            st.error("Mock not found")
            return

        with st.form(f"edit_mock_{mock_id}"):
            col1, col2 = st.columns(2)

            with col1:
                new_title = st.text_input("Title", value=mock.get('title', ''))
                new_category = st.selectbox(
                    "Category",
                    ["Programming", "Mathematics", "Science", "Business", "General"],
                    index=["Programming", "Mathematics", "Science", "Business", "General"].index(
                        mock.get('category', 'General')
                    )
                )
                new_price = st.number_input("Price (Credits)", value=mock.get('price_credits', 1), min_value=1)

            with col2:
                new_description = st.text_area("Description", value=mock.get('description', ''))
                new_explanation_enabled = st.checkbox("Enable Explanations", value=mock.get('explanation_enabled', True))
                new_is_active = st.checkbox("Active", value=mock.get('is_active', True))

            col1, col2, col3 = st.columns(3)

            with col1:
                if st.form_submit_button("üíæ Save Changes", use_container_width=True, type="primary"):
                    success = run_async(update_mock(mock_id, {
                        'title': new_title,
                        'description': new_description,
                        'category': new_category,
                        'price_credits': new_price,
                        'explanation_enabled': new_explanation_enabled,
                        'is_active': new_is_active
                    }))

                    if success:
                        st.success("Mock updated successfully!")
                        st.session_state.show_edit_form = False
                        st.session_state.edit_mock_id = None
                        st.rerun()
                    else:
                        st.error("Failed to update mock")

            with col2:
                if st.form_submit_button("‚ùå Cancel", use_container_width=True):
                    st.session_state.show_edit_form = False
                    st.session_state.edit_mock_id = None
                    st.rerun()

def show_delete_confirmation(mock_id: str):
    """Show delete confirmation dialog"""
    mock = run_async(load_mock_by_id(mock_id))

    if not mock:
        st.error("Mock not found")
        return

    with st.expander("üóëÔ∏è Delete Mock Exam", expanded=True):
        st.warning(f"Are you sure you want to delete **{mock.get('title', 'Unknown Mock')}**?")
        st.markdown("This action cannot be undone!")

        col1, col2 = st.columns(2)

        with col1:
            if st.button("üóëÔ∏è Yes, Delete", use_container_width=True, type="primary"):
                success = run_async(delete_mock(mock_id))

                if success:
                    st.success("Mock deleted successfully!")
                    st.session_state.show_delete_confirm = False
                    st.session_state.delete_mock_id = None
                    st.rerun()
                else:
                    st.error("Failed to delete mock")

        with col2:
            if st.button("‚ùå Cancel", use_container_width=True):
                st.session_state.show_delete_confirm = False
                st.session_state.delete_mock_id = None
                st.rerun()

# Handle edit form
if st.session_state.get('show_edit_form') and st.session_state.get('edit_mock_id'):
    show_edit_mock_form(st.session_state.edit_mock_id)

# Handle delete confirmation
if st.session_state.get('show_delete_confirm') and st.session_state.get('delete_mock_id'):
    show_delete_confirmation(st.session_state.delete_mock_id)

async def load_all_mocks() -> List[Dict[str, Any]]:
    """Load all mock exams from database"""
    from db import db_manager as db
    mocks = await db.get_all_mocks(active_only=False)

    # Convert Mock objects to dictionaries
    result = []
    for mock in mocks:
        if hasattr(mock, '__dict__'):
            # It's a Mock object, convert to dict
            mock_dict = {
                'id': mock.id,
                'title': mock.title,
                'description': mock.description,
                'category': getattr(mock, 'category', 'General'),
                'questions_json': mock.questions,
                'price_credits': mock.price_credits,
                'explanation_enabled': mock.explanation_enabled,
                'is_active': mock.is_active,
                'created_at': str(mock.created_at) if hasattr(mock, 'created_at') else None
            }
            result.append(mock_dict)
        else:
            # Already a dict
            result.append(mock)

    return result

async def load_mock_by_id(mock_id: str) -> Dict[str, Any]:
    """Load a specific mock by ID"""
    from db import db_manager as db
    mock = await db.get_mock_by_id(mock_id)

    if mock and hasattr(mock, '__dict__'):
        # It's a Mock object, convert to dict
        return {
            'id': mock.id,
            'title': mock.title,
            'description': mock.description,
            'category': getattr(mock, 'category', 'General'),
            'questions_json': mock.questions,
            'price_credits': mock.price_credits,
            'explanation_enabled': mock.explanation_enabled,
            'is_active': mock.is_active,
            'created_at': str(mock.created_at) if hasattr(mock, 'created_at') else None
        }

    return mock

async def update_mock(mock_id: str, update_data: Dict[str, Any]) -> bool:
    """Update a mock exam"""
    from db import db
    return await db.update_mock(mock_id, update_data)

async def delete_mock(mock_id: str) -> bool:
    """Delete a mock exam"""
    from db import db
    return await db.delete_mock(mock_id)

async def regenerate_explanations(mock_id: str) -> bool:
    """Regenerate AI explanations for a mock"""
    try:
        from openrouter_utils import openrouter_manager

        mock = await load_mock_by_id(mock_id)
        if not mock:
            return False

        questions = mock.get('questions_json', [])

        for question in questions:
            # Generate explanation using OpenRouter
            explanation = await openrouter_manager.generate_explanation(
                question['question'],
                question['choices'],
                question['correct_index']
            )
            question['explanation_template'] = explanation

        # Update mock with new explanations
        return await update_mock(mock_id, {'questions_json': questions})

    except Exception as e:
        st.error(f"Error regenerating explanations: {str(e)}")
        return False

def get_unique_categories(mocks: List[Dict[str, Any]]) -> List[str]:
    """Get unique categories from mocks"""
    categories = set()
    for mock in mocks:
        category = mock.get('category', 'General')
        if category:
            categories.add(category)
    return sorted(list(categories))

def filter_mocks(mocks: List[Dict[str, Any]], search_term: str,
                 category_filter: str, status_filter: str) -> List[Dict[str, Any]]:
    """Filter mocks based on search criteria"""
    filtered = mocks

    # Search filter
    if search_term:
        filtered = [
            mock for mock in filtered
            if search_term.lower() in mock.get('title', '').lower() or
               search_term.lower() in mock.get('description', '').lower()
        ]

    # Category filter
    if category_filter != "All":
        filtered = [
            mock for mock in filtered
            if mock.get('category', 'General') == category_filter
        ]

    # Status filter
    if status_filter == "Active":
        filtered = [mock for mock in filtered if mock.get('is_active', True)]
    elif status_filter == "Inactive":
        filtered = [mock for mock in filtered if not mock.get('is_active', True)]

    return filtered
